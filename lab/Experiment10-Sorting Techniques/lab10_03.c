/*
请设计shell排序算法函数void shellSort(int a[],int n)，对a[1]..a[n]进行升序排序。
并测试在不同数据规模下的排序效率。
*/
#include "Arrayio.h"
#include <time.h>
#define N 500000     /*N为数据量大小，因data1.txt中只有50万个数，所以自行设定N值时需让N<=500000*/

/*请将本函数补充完整，并进行测试*/
/*
shell本质上是一种插入排序的改进，他利用了插入排序的两个优点
1: 数据量比较小的时候与ON差别不大
  希尔排序在增量大的时候，分组后的元素少，满足这一点
2：数据量大的时候若有序的比较多，也不会和ON拉开多少差距
  希尔排序在增量小的时候，分组后的元素即便比较多，但因为之前排好了，所以满足这一点

*/
void shellSort(int a[],int n)
//增量序列怎么选会影响最终的效率，但是现在也没研究出具体的结果来，目前主流的还是每次除二这样，但无论怎么取增量，最后一定都得是1才能通过有序性检验
//shell排序属于一种不稳定的排序，平均时间复杂度为On1.3
//想过一个比较好写的代码的实现方法，就是再建一个等长数组空间存储每次shell更新增量后对应的下标，但是这样会导致空间复杂度上了一个台阶且对时间复杂度无影响，还是多啃一回标准是怎么写的吧
//
{
  for(int d = n / 2; d >= 1; d /= 2){      //定义增量，这点应该全世界都是一样的
    for(int i = d + 1; i <= n; i++){         //定义i作为一个一直指向（待排数）的指针(从分组后第二个数开始)，j作为一个寻找适应位置下标的指针
      if(a[i] < a[i - d]){
        a[0] = a[i];  //小了才要做移动和比较的操作，大了直接不管了，所以j和移动全在if真条件里去
        int j = i - d;
        do{
          a[j + d] = a[j];
          j -= d;
        }while(j >= 1 && a[j] > a[0]);    //dowhile做移动，确保都能移动上一次,移动几次取决于j-=d后还剩下几次能活,只要待插数还比前一个数要小，那就继续移，等于也不用管了反正本身就是不稳定的排序
        a[j + d] = a[0];
      }

    }
  }
}

int  main()
{
  int a[N+1],n;                     /*数据存储在a[1]...a[N]中*/
  printf("数据初始化...\n");
  n=readData(a,N,"data1.txt");      /*从data1.txt中读入N个整数存入数组a，n为实际读入的数据个数*/
  printf("%d个数据排序中...\n",n);
  clock_t beg = clock();
  shellSort(a, n);
  clock_t end = clock();
  saveData(a,n,"out.txt");          /*排序结果存放在out.txt文件中*/
  printf("排序结束，排序结果保存在out.txt文件中。\n");
  printf("n=%d,  time = %.3f ms\n",
         n, 1000.0 * (end - beg) / CLOCKS_PER_SEC);
  return 0;
}
