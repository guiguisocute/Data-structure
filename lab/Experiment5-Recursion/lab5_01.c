/*
  编写递归算法int max(int a[],int left, int right)，求数组a[left..right]中的最大数。
*/
 
#include "ArrayIo.h"
/*请将本函数补充完整，并进行测试*/
//对于曾梓豪这种高考数学70分的来说，想要理解好递归，就不要把代码中调用自己的部分当成调用自己，而是当成**另一个函数**，只是名称和代码与原函数一模一样而已，这样就好理解了，当运行到调用自己的时候，就当作是进入了另一个函数执行，当另一个函数退出返回之后就继续执行下一行，这样就不会乱了

int max(int a[],int left,int right)
//递归的算法解释当然可以就一句话随便带过，毕竟关键就一个，说一句递归调用就可以了……但是毕竟是复习（maybe预习），所以这次的算法解释我们逐步来编写
{
  //首先第一步，防空一切思想，不要去管怎么实现的，先百分百确定你这个函数到底可以对形参执行什么样的操作，形成什么样的结果，这样你才能在递归中绕出“调用自己”这个非常正确但又可恶的思想，去想想整体

  if(left == right){    //最后再写终止条件
    return a[left];
  }else{
    int max1 = max(a,left,right - 1);     //其实写递归函数的时候，这个递归反而应该是先写的，因为你连该怎么调用都不清楚，你怎么思考终止条件呢？这个语句的意思就是，右边的“新函数”已经把那个左索引到右-1的最大值给返回过来了，我们把它复制给max1
    return (max1 > a[right]) ? max1 : a[right]; //后面就是max1和最右的对比咯，用三元运算符比较一下然后返回更大的，这个小学生都明白吧，而且因为最开始那个max其实已经把除了最右边的最大值给返回了（不要管是怎么做到的），所以函数这个时候理应结束了。
    //现在就想想那个函数时怎么返回的，毕竟这个“新”函数是和我们正在写的函数名称和语句完全一样的函数，此时顺着想，wok，它居然可以不断把这个左右索引一点一点缩小，而且最后一定会把数组所有值都遍历到
    //那么很容易想到终止条件，就是左边索引等于右索引的时候，毕竟这时候就重合了，再-1就失去逻辑意义了，由于此时指向都是同一个cell所以直接返回任意一个就行了
  }
}
int main()
{   int a[10];
    input(a,10);
    print(a,10);
    printf("数组的最大数是:%d\n",max(a,0,9));
    return 0;
}
