/*********************************************/
/*          实验8.4  Prim求解最小生成树算法    */
/*********************************************/
#include "ljjz.h"
typedef struct edgedata  /*用于保存最小生成树的边类型定义*/
       {
         int beg, en;    /*beg,en是边顶点序号，分别保存这一条边所连接的两个顶点在邻接矩阵中的下标，就是<beg,en>这种形式*/
         int length;     /*边长，这条边的权值*/
       }edge;

/*函数功能：prim算法构造最小生成树   函数参数：图的邻接矩阵g;边向量edge*/
/*prim就是最最最传统的贪心，构建一个新图（注意是图）现在称为图A，原始的图我称为是图B，从随机一点开始，把这个顶点归成先放进图A中（当然此时这个顶点也不属于图B了），然后，从图B（原始图）中的所有顶点出发，找一条和图A某个顶点相连并且权值最小的边，把这条边和顶点都放进图A中，循环往复直到图B没有任何顶点了*/
void prim(Mgraph g, edge tree[M-1])
{  edge x;
   int d,min,j,k,s,v;

   /*尝试去理解这些预设的变量
   x 作为两条候选边交换的temp
   d 临时权值，如果这跟权比之前图要小，那么就换过去
   min 当前最小的权值，初始为未被放好的tree矩阵
   j 遍历那两个新的标准的数据结构的索引？
   k 始终指向最小的两栖边（链接两图的边），且长时间标识着生成树当前进度的指针。
   s 加入新图的顶点下标，*本*轮找出的“最小边”所对应的那个新顶点的下标（原本是从图A里），使得k
   v 马上要加入的那个顶点的下标
   */

  //这里得注意一下揭老师给的实现方法并不是传统构建两个数组一个存最小权一个存另外顶点下标，而是把它们合并到一起了

   /* 建立初始入选点，并初始化生成树边集tree*/
  for(v = 1; v <= g.n - 1; v++)
  { // v = 1 为了直接跳过矩阵主对角线赋权值
    tree[v - 1].beg = 0;
    tree[v - 1].en = v;
    tree[v - 1].length = g.edges[0][v];
  }

  /*依次求当前(第k条）最小两栖边,并加入树集(加入树集的意思就是放在最前面，这个表述真的是……)
  （to be honeset我不是很喜欢这个说法，大部分教材也不用两栖边这个词了，大白话翻译一下就是同时连接A图和B图的边呗，我不喜欢生造术语），*/
  for(k = 0; k < g.n - 1; k++){   //本身tree集就只有 n-1个，所以遍历到n-1就可以了
    min = tree[k].length;
    s = k;
    for(j = k + 1; j < g.n - 1; j++){
      if(tree[j].length < min){
        min = tree[j].length;
        s = j;
      }
    }

    x = tree[k];
    tree[k] = tree[s];
    tree[s] = x;
    v = tree[k].en;   
    //交换任务完成，接下来就是放更小的权值进新图（tree集）
    /*由于新顶点v的加入，修改两栖边的基本信息*/
    for(j = k + 1; j < g.n - 1; j++){
      d = g.edges[v][tree[j].en];
      if(tree[j].length > d){
        tree[j].length = d;
        tree[j].beg = v;
      }
    }
  }


  /*输出最小生成树*/
  printf("\n最小生成树是:\n");   /*输出最小生成树*/
  for (j = 0; j < g.n - 1; j++) // 图中顶点总数 - 2？ why，啊，一共有n-1条边，所以
    printf("\n%c---%c  %d\n", g.vexs[tree[j].beg], g.vexs[tree[j].en], tree[j].length);
  printf("\n最小生成树的根是： %c\n", g.vexs[0]);
 }

int  main()
  {
   Mgraph g;
   edge  tree[M-1];  /*用于存放最小生成树的M-1条边*/
   creat(&g,"G.txt",0);  /*创建无向图的邻接矩阵*/
   print(g);
   prim(g,tree);        /*求解图的最小生成树*/
   return 0;

  }

